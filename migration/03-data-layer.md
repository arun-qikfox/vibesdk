# 03 - Data Layer Migration

Goal: Replace Cloudflare data bindings (D1, KV, R2, Secrets) with Google Cloud managed services while keeping the data access patterns in `worker/database` and `worker/config` unchanged.

## Outcomes
- Cloud SQL instance (PostgreSQL 15) with schema generated by Drizzle.
- Drizzle client abstraction that swaps between Cloudflare D1 (`drizzle-orm/d1`) and Postgres (`drizzle-orm/postgres-js`) based on environment.
- KV operations backed by Firestore or Memorystore.
- Template assets stored in Cloud Storage buckets.
- Secrets sourced from Secret Manager at runtime and during local development.

## Prerequisites
- Landing zone and runtime service from previous specs.
- Terraform modules ready to extend (`infra/gcp/modules/sql`, etc.).
- Familiarity with Drizzle migrations and schema translation from SQLite to Postgres types.

## Implementation Steps

### Step 1: Provision Cloud SQL
- [ ] Add Terraform module `infra/gcp/modules/sql` that creates:
  - PostgreSQL 15 instance (`vibesdk-sql`) with private IP.
  - Database `vibesdk`.
  - User `vibesdk_app` with generated password stored in Secret Manager.
- [ ] Enable automated backups and high availability (zonal) if budget permits.
- [ ] Output connection string for use in Cloud Run.

### Step 2: Translate Schema
- [ ] Export current D1 schema from `worker/database/schema.ts`.
- [ ] Create `drizzle.config.gcp.ts` pointing to Postgres (use `postgres-js` driver).
- [ ] Run `bunx drizzle-kit generate --config=drizzle.config.gcp.ts` to produce migration SQL.
- [ ] Review type differences (e.g., `integer` vs `bigint`) and adjust schema definitions carefully to avoid breaking the agent logic.
- [ ] Document any schema deviations in `migration/NOTES.md`.

### Step 3: Abstraction Layer
- [ ] Introduce `worker/database/clients/index.ts` exporting a factory `createDatabase(env: Env | GcpEnv)`.
- [ ] Refactor `worker/database/database.ts:6-72` to call the factory instead of instantiating `drizzle(env.DB)`.
- [ ] Define `GcpEnv` interface mirroring required bindings (connection URI, pool).
- [ ] Ensure rate-limit and analytics services reuse the same factory.

### Step 4: Connect Cloud Run to Cloud SQL
- [ ] Add Cloud SQL proxy connector to the Cloud Run service defined in `02-runtime-platform.md`.
- [ ] Inject DATABASE_URL via Secret Manager (format: `postgres://user:password@//cloudsql/PROJECT:REGION:INSTANCE/db`).
- [ ] Update runtime entry (`worker/index.ts:59-121`) to read from `env.DATABASE_URL` when `env.DB` is missing.
- [ ] Provide fallback logic so Cloudflare deployment still works.

### Step 5: KV Migration (Config, Cache, Rate Limits)
- [ ] Decide storage backend:
  - Firestore (strong consistency, simpler for JSON blobs).
  - Memorystore (Redis) for high-throughput rate limiting.
- [ ] Create adapter `shared/platform/kv/kvProvider.ts` exposing `get/put/delete/list`.
- [ ] Update call sites such as `worker/config/index.ts:110-158`, `worker/services/rate-limit/rateLimits.ts:90-124`, and `worker/services/cache/KVCache.ts:48-92` to use the adapter rather than `env.VibecoderStore`.
- [ ] Implement two providers:
  - `cloudflareKVProvider` (current behaviour).
  - `gcpFirestoreProvider` or `gcpRedisProvider`.
- [ ] Store Firestore credentials using workload identity (Cloud Run service account already granted access).

### Step 6: R2 Templates â†’ Cloud Storage
- [ ] Provision bucket `vibesdk-templates` with uniform bucket-level access.
- [ ] Add lifecycle rule for stale templates if desired.
- [ ] Create adapter `shared/platform/storage/objectStore.ts` wrapping `put/get/delete`.
- [ ] Update usages in `worker/services/sandbox/BaseSandboxService.ts:70-92`, `worker/utils/images.ts:69-142`, and `worker/api/controllers/screenshots/controller.ts:78-110`.
- [ ] Ensure `scripts/setup.ts` and `scripts/deploy.ts` read bucket info from new config.

### Step 7: Secrets and Config
- [ ] Replace direct access to `env.JWT_SECRET` et al with helper that reads from `Secret Manager` when on GCP.
- [ ] Provide a local development `.env.gcp` file that loads secrets via `gcloud secrets versions access`.
- [ ] Update documentation (`docs/setup.md`) after verifying the flow (defer actual edits until migration complete).

## Verification
- [ ] Run migrations against Cloud SQL and confirm schema with `pg_dump --schema-only`.
- [ ] Deploy Cloud Run revision and hit `/api/config` (or similar) to ensure DB queries succeed.
- [ ] Persist data via endpoints that previously touched KV/R2 and confirm appearance in Firestore/Cloud Storage.
- [ ] Check logs for adapter selection to confirm runtime is using the intended provider.

## Dependencies
- Durable Object storage is handled in `04-durable-objects-and-sandbox.md`.
- App deployment templates continue to use Cloud Storage after this step.

